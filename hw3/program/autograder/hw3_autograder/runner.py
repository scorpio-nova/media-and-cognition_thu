# DO NOT EDIT this file. It is set up in such a way that if you make any edits,
# the test cases may change resulting in a broken local autograder.

# Imports
import numpy as np
import sys, os, pdb
from test_rnn import RNN_Test

# Append paths and run
sys.path.append('mytorch')
from gru_cell import *

sys.path.append('hw3')

import hw3

isTesting = True

# DO NOT CHANGE -->
EPS = 1e-20
SEED = 2021
np.random.seed(SEED)

# Tests
def assertions(user_vals, expected_vals, test_type, test_name):
    if test_type == 'type':
        try:
            assert type(user_vals) == type(expected_vals)
        except Exception as e:
            print('Type error, your type doesnt match the expected type.')
            print('Wrong type for %s' % test_name)
            print('Your type:   ', type(user_vals))
            print('Expected type:', type(expected_vals))
            return False
    elif test_type == 'shape':
        try:
            assert user_vals.shape == expected_vals.shape
        except Exception as e:
            print('Shape error, your shapes doesnt match the expected shape.')
            print('Wrong shape for %s' % test_name)
            print('Your shape:    ', user_vals.shape)
            print('Expected shape:', expected_vals.shape)
            return False
    elif test_type == 'closeness':
        try:
            assert np.allclose(user_vals, expected_vals)
        except Exception as e:
            print('Closeness error, your values dont match the expected values.')
            print('Wrong values for %s' % test_name)
            print('Your values:    ', user_vals)
            print('Expected values:', expected_vals)
            return False
    return True


############################################################################################
################################     Step I - GRU     ######################################
############################################################################################
def gru_cell_forward(cur_input, cur_result):
    # Get cur inputs
    input_dim = cur_input[0]
    hidden_dim = cur_input[1]
    seq_len = cur_input[2]

    data = np.random.randn(seq_len, input_dim)
    hidden = np.random.randn(hidden_dim)

    user_gru_cell = GRU_Cell(input_dim, hidden_dim)
    user_result = user_gru_cell.forward(data[0], hidden)

    if not assertions(user_result, cur_result, 'type', 'h_t'): return False
    if not assertions(user_result, cur_result, 'shape', 'h_t'): return False
    if not assertions(user_result, cur_result, 'closeness', 'h_t'): return False

    return True

def test_gru_forward():
    inputs = [[100, 150, 10], [90, 140, 8]]
    expected_results = np.load(os.path.join('autograder', 'hw3_autograder',
                               'data', 'gru_forward.npy'), allow_pickle = True)
    n = 2
    for i in range(2):
        cur_result = expected_results[i]
        cur_input = inputs[i]
        result = gru_cell_forward(cur_input, cur_result)
        if result != True:
            print('Failed GRU Forward Test: %d / %d' % (i + 1, n))
            return False
        else:
            print('Passed GRU Forward Test: %d / %d' % (i + 1, n))

    # Use to save test data for next semester
    # np.save(os.path.join('autograder', 'hw3_autograder',
    #                      'data', 'gru_forward.npy'), results, allow_pickle=True)

    return True

def gru_cell_backward(forward_vals, dxdh, dws):
    input_dim = 5
    hidden_dim = 2
    seq_len = 10

    # Foward Pass -------------------------->
    data = np.random.randn(seq_len, input_dim)
    hidden = np.random.randn(hidden_dim)

    user_gru_cell = GRU_Cell(input_dim, hidden_dim)
    user_result = user_gru_cell.forward(data[0], hidden)

    if not assertions(user_result, forward_vals, 'type', 'h_t'): return False
    if not assertions(user_result, forward_vals, 'shape', 'h_t'): return False
    if not assertions(user_result, forward_vals, 'closeness', 'h_t'): return False
    # <--------------------------------------

    # Backward pass -------------------------->
    delta = np.random.randn(hidden_dim)
    delta = delta.reshape(1, -1)
    dx, dh = user_gru_cell.backward(delta)
    dx_t, dh_t = dxdh

    if not assertions(dx, dx_t, 'type', 'dx_t'): return False
    if not assertions(dx, dx_t, 'shape', 'dx_t'): return False
    if not assertions(dx, dx_t, 'closeness', 'dx_t'): return False

    if not assertions(dh, dh_t, 'type', 'dh_t'): return False
    if not assertions(dh, dh_t, 'shape', 'dh_t'): return False
    if not assertions(dh, dh_t, 'closeness', 'dh_t'): return False

    dWzh, dWrh, dWh, dWzx, dWrx, dWx = dws

    if not assertions(user_gru_cell.dWzh, dWzh, 'closeness', 'dWzh'): return False
    if not assertions(user_gru_cell.dWrh, dWrh, 'closeness', 'dWrh'): return False
    if not assertions(user_gru_cell.dWzx, dWzx, 'closeness', 'dWzx'): return False
    if not assertions(user_gru_cell.dWrx, dWrx, 'closeness', 'dWrx'): return False
    if not assertions(user_gru_cell.dWh,  dWh, 'closeness', 'dWh'): return False
    if not assertions(user_gru_cell.dWx,  dWx, 'closeness', 'dWx'): return False
    # <--------------------------------------

    return True

def test_gru_backward():
    # Test dWs
    expected_results = np.load(os.path.join('autograder', 'hw3_autograder',
                               'data', 'gru_backward.npy'), allow_pickle=True)

    n = 2
    for i in range(2):
        forward_vals, dxdh, dws = expected_results[i]
        result = gru_cell_backward(forward_vals, dxdh, dws)
        if result != True:
            print('Failed GRU Backward Test: %d / %d' % (i + 1, n))
            return False
        else:
            print('Passed GRU Backward Test: %d / %d' % (i + 1, n))

    # Use to save test data for next semester
    # np.save(os.path.join('autograder', 'hw3_autograder',
    #                      'data', 'gru_backward.npy'), results, allow_pickle=True)

    return True

def generate(mu, sigma, FEATURE_DIM):
    return sigma*np.random.randn(1,FEATURE_DIM) + mu

def create_input_data(SEQUENCE, FEATURE_DIM):
    mean_a = [1.0] * FEATURE_DIM
    mean_b = [5.0] * FEATURE_DIM
    mean_c = [10.0] * FEATURE_DIM

    mean = {'a':mean_a, 'b':mean_b, 'c':mean_c}

    sigma  = 0.2

    inputs = []

    for char in SEQUENCE:
        v = generate(np.array(mean[char]), sigma, FEATURE_DIM)
        inputs.append(v)

    inputs = np.vstack(inputs)
    return inputs

def test_gru_inference():
    ref_outputs = np.load(os.path.join('autograder', 'hw3_autograder',
                               'data', 'gru_inference.npy'), allow_pickle=True)

    FEATURE_DIM = 7
    HIDDEN_DIM = 4
    NUM_CLASSES = 3

    SEQUENCE = 'aaabbbbccc'
    inputs = create_input_data(SEQUENCE, FEATURE_DIM)

    w_ir = np.random.randn(HIDDEN_DIM, FEATURE_DIM)
    w_ii = np.random.randn(HIDDEN_DIM, FEATURE_DIM)
    w_in = np.random.randn(HIDDEN_DIM, FEATURE_DIM)
    w_hr = np.random.randn(HIDDEN_DIM, HIDDEN_DIM)
    w_hi = np.random.randn(HIDDEN_DIM, HIDDEN_DIM)
    w_hn = np.random.randn(HIDDEN_DIM, HIDDEN_DIM)


    # Load weights into student implementation
    student_net = hw3.CharacterPredictor(FEATURE_DIM, HIDDEN_DIM, NUM_CLASSES)
    student_net.init_rnn_weights(w_hi, w_hr, w_hn, w_ii, w_ir, w_in)

    student_outputs = hw3.inference(student_net, inputs)

    if not assertions(student_outputs, ref_outputs, 'type', 'gru inference output'):
        return False
    if not assertions(student_outputs, ref_outputs, 'shape', 'gru inference output'):
        return False
    if not assertions(student_outputs, ref_outputs, 'closeness', 'gru inference output'):
        return False

    # Use to save test data for next semester
    # np.save(os.path.join('autograder', 'hw3_autograder',
    #                      'data', 'gru_inference.npy'), student_outputs, allow_pickle=True)

    return True

############################################################################################
########################## DO NOT EDIT #########################################
############################################################################################

if __name__ == '__main__':
    # DO NOT EDIT

    rnntest = RNN_Test()
    rnn_test_outcome = rnntest.run_test()

    np.random.seed(SEED)

    # DO NOT EDIT
    print('-'*20)
    print('Step II - GRU Foward')
    gru_forward_outcome = test_gru_forward()

    print('GRU Forward: ', 'PASS' if gru_forward_outcome else '*** FAIL ***')
    print('-'*20)
    print()

    if gru_forward_outcome == False:
        print('*'*77)
        print('The local autograder will not work if you do not pass GRU Foward.')
        print('*'*77)
        print(' ')
        exit(0)

    # DO NOT EDIT
    print('-'*20)
    print('Step II - GRU Backward')
    gru_backward_outcome = test_gru_backward()
    print('GRU Backward: ', 'PASS' if gru_backward_outcome else '*** FAIL ***')
    print('-'*20)
    print()
    if gru_backward_outcome == False:
        print('*'*77)
        print('The local autograder will not work if you do not pass GRU Backward.')
        print('*'*77)
        print(' ')
        exit(0)

    # DO NOT EDIT
    print('-'*20)
    gru_inference_outcome = test_gru_inference()
    print('Step II - GRU Inference')
    print('GRU Inference: ', 'PASS' if gru_inference_outcome else '*** FAIL ***')
    print('-'*20)
    print()